<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SL-bussar i realtid</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <style>
    :root { --bg:#0b0c10; --panel:#151824; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4f46e5; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    header{padding:10px 14px;background:var(--panel);display:flex;flex-wrap:wrap;gap:10px;align-items:center;position:sticky;top:0;z-index:2}
    label{opacity:.9}
    input,button{border:1px solid #23273a;background:#0f1320;color:var(--text);padding:9px 12px;border-radius:10px}
    input{min-width:90px}
    button{cursor:pointer}
    .row{display:flex;gap:10px;align-items:center}
    #status{padding:8px 14px;color:var(--muted)}
    #map{height:calc(100vh - 108px)}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:2px 8px;border:1px solid #2a2f43;border-radius:999px;margin-left:6px;color:#cbd5e1}
    .small{font-size:12px;opacity:.85}
  </style>
</head>
<body>
  <header>
    <form id="line-form" class="row">
      <label for="line">Linje</label>
      <input id="line" placeholder="t.ex. 4" required inputmode="numeric" />
      <button id="go" type="submit" title="Visa bussar">Visa</button>
    </form>
    <div class="row">
      <label for="auto">Auto-uppdatera</label>
      <input id="auto" type="checkbox" />
      <span class="pill small" id="meta">laddar…</span>
    </div>
  </header>

  <div id="status">Laddar statiska filer första gången…</div>
  <div id="map"></div>

  <!-- Libs -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js"></script>

  <script>
  // ================== KONFIG ==================
  // Din Cloudflare-proxy. Default enligt din preferens:
  const API_PROXY = "https://buss-proxy.nyhet24-tokamak.workers.dev"; // ev. byt till din buss-proxy
  // Trafiklab-nycklar (om du inte gömmer dem i Workern)
  const TL_RT_KEY     = "ac506a874e764f75a02d214788ec2124";     // GTFS Regional Realtime
  const TL_STATIC_KEY = "b2f9006366ce457dab592e5e3ca60410"; // GTFS Regional Static (sl.zip)

  // Proxade upstream-URL:er
  const VEH_URL = `${API_PROXY}/?url=${encodeURIComponent(
    `https://opendata.samtrafiken.se/gtfs-rt/sl/VehiclePositions.pb?key=${TL_RT_KEY}`
  )}`;
  const TRIPUPD_URL = `${API_PROXY}/?url=${encodeURIComponent(
    `https://opendata.samtrafiken.se/gtfs-rt/sl/TripUpdates.pb?key=${TL_RT_KEY}`
  )}`;
  const SL_ZIP  = `${API_PROXY}/?url=${encodeURIComponent(
    `https://opendata.samtrafiken.se/gtfs/sl/sl.zip?key=${TL_STATIC_KEY}`
  )}`;

  // =============== Minimal GTFS-RT .proto (VehiclePositions + TripUpdates) ===============
  const GTFS_PROTO = `
  syntax = "proto2";
  package transit_realtime;

  message FeedMessage { required FeedHeader header = 1; repeated FeedEntity entity = 2; }
  message FeedHeader { required string gtfs_realtime_version = 1; optional uint64 timestamp = 3; }
  message FeedEntity { required string id = 1; optional TripUpdate trip_update = 2; optional VehiclePosition vehicle = 3; }

  message TripDescriptor { optional string trip_id = 1; optional string route_id = 5; }
  message VehicleDescriptor { optional string id = 1; optional string label = 2; }
  message Position { optional float latitude = 1; optional float longitude = 2; optional float bearing = 3; optional float speed = 5; }

  message StopTimeEvent { optional int32 delay = 1; optional int64 time = 2; optional int32 uncertainty = 3; }
  message StopTimeUpdate {
    optional uint32 stop_sequence = 1;
    optional string stop_id = 4;
    optional StopTimeEvent arrival = 2;
    optional StopTimeEvent departure = 3;
  }

  message TripUpdate {
    optional TripDescriptor trip = 1;
    repeated StopTimeUpdate stop_time_update = 2;
    optional VehicleDescriptor vehicle = 3;
    optional uint64 timestamp = 4;
  }

  message VehiclePosition {
    optional TripDescriptor trip = 1;
    optional Position position = 2;
    optional int32 current_stop_sequence = 3;
    optional uint64 timestamp = 5;
    optional VehicleDescriptor vehicle = 8;
  }`;
  const root = protobuf.parse(GTFS_PROTO).root;
  const FeedMessage = root.lookupType("transit_realtime.FeedMessage");

  // =============== KARTA & STATE ===============
  const map = L.map("map").setView([59.3328, 18.0649], 12);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution:"© OpenStreetMap" }).addTo(map);

  let markers = [];
  let ROUTES_BY_SHORT = new Map();   // '4' -> Set(route_id, ...)
  let SHORT_BY_ROUTE  = new Map();   // route_id -> '4'
  let TRIP_TO_ROUTE   = new Map();   // statiskt: trip_id -> route_id
  let VEHICLE_TO_ROUTE = new Map();  // realtid: vehicle.id -> route_id (från TripUpdates)
  let currentLine = null;
  let autoTimer = null;

  const $status = document.getElementById("status");
  const $meta   = document.getElementById("meta");
  const $auto   = document.getElementById("auto");
  const $line   = document.getElementById("line");
  const $go     = document.getElementById("go");
  const setStatus = (t) => { $status.textContent = t; console.log(t); };

  // Gatea UI tills statiken är klar
  let staticReadyResolve; const staticReady = new Promise(res => (staticReadyResolve = res));
  $line.disabled = true; $go.disabled = true;

  // —— Hjälpare —— //
  function guessShortFromRouteId(routeId) {
    // SL-format: ofta 16 siffror; mittblock (index 8–11) innehåller linjenumret
    if (!/^\d{10,18}$/.test(routeId)) return null;
    const mid = routeId.slice(8, 12);        // "0040" → 40
    const n = parseInt(mid, 10);
    if (Number.isNaN(n)) return null;
    return String(n % 10 === 0 ? n / 10 : n); // 0040 -> "4", 0401 -> "401"
  }

  function shortFromTrip(trip) {
    if (!trip) return null;
    const rid = (trip.routeId || TRIP_TO_ROUTE.get((trip.tripId||"").trim()) || "").trim();
    if (!rid) return null;
    return SHORT_BY_ROUTE.get(rid) || guessShortFromRouteId(rid) || null;
  }

  // =============== Ladda statisk GTFS (routes & trips) ===============
  async function loadStatic() {
    try {
      setStatus("Hämtar sl.zip…");
      const res = await fetch(SL_ZIP);
      if (!res.ok) throw new Error(`sl.zip misslyckades: ${res.status}`);
      const buf = await res.arrayBuffer();
      const zip = await JSZip.loadAsync(buf);

      // routes.txt — robust parsing via Papa arrays (indexbaserat)
      const routesTxt = await zip.file("routes.txt").async("string");
      const routesParsed = Papa.parse(routesTxt, { header:false, skipEmptyLines:true }).data;
      // förväntad header på rad 0: route_id,agency_id,route_short_name,route_long_name,route_type,route_desc
      ROUTES_BY_SHORT = new Map();
      SHORT_BY_ROUTE  = new Map();
      for (let i = 1; i < routesParsed.length; i++) {
        const row = routesParsed[i];
        if (!row || row.length < 3) continue;
        const routeId = String(row[0] ?? "").trim();
        const short   = String(row[2] ?? "").trim();
        if (!routeId || !short) continue;
        if (!ROUTES_BY_SHORT.has(short)) ROUTES_BY_SHORT.set(short, new Set());
        ROUTES_BY_SHORT.get(short).add(routeId);
        SHORT_BY_ROUTE.set(routeId, short);
      }

      // trips.txt — också indexbaserat (header: route_id,service_id,trip_id,...)
      const tripsTxt = await zip.file("trips.txt").async("string");
      const tripsParsed = Papa.parse(tripsTxt, { header:false, skipEmptyLines:true }).data;
      TRIP_TO_ROUTE = new Map();
      for (let i = 1; i < tripsParsed.length; i++) {
        const row = tripsParsed[i];
        if (!row || row.length < 3) continue;
        const routeId = String(row[0] ?? "").trim();
        const tripId  = String(row[2] ?? "").trim();
        if (tripId && routeId) TRIP_TO_ROUTE.set(tripId, routeId);
      }

      setStatus(`Statiska filer klara: ${ROUTES_BY_SHORT.size} linjer, ${TRIP_TO_ROUTE.size} trips mappade.`);
      $meta.textContent = "redo";
      $line.disabled = false; $go.disabled = false;
      staticReadyResolve();
    } catch (err) {
      console.error(err);
      setStatus("Kunde inte ladda statisk data (sl.zip). Har din nyckel åtkomst?");
      $meta.textContent = "fel statiskt";
    }
  }

  // =============== Hämta TripUpdates och bygg vehicle -> route (realtid) ===============
  async function loadTripUpdates() {
    try {
      VEHICLE_TO_ROUTE.clear();
      const res = await fetch(TRIPUPD_URL);
      if (!res.ok) { console.warn("TripUpdates misslyckades:", res.status); return; }
      const buf = await res.arrayBuffer();
      const fm = FeedMessage.decode(new Uint8Array(buf));
      for (const ent of (fm.entity || [])) {
        const tu = ent.tripUpdate;
        if (!tu) continue;
        const rid = (tu.trip?.routeId || TRIP_TO_ROUTE.get((tu.trip?.tripId||"").trim()) || "").trim();
        const vid = (tu.vehicle?.id || "").trim();
        if (rid && vid) VEHICLE_TO_ROUTE.set(vid, rid);
      }
    } catch (err) {
      console.warn("Kunde inte ladda/avkoda TripUpdates:", err);
    }
  }

  // =============== Hämta VehiclePositions & filtrera ===============
  async function fetchPositions(lineShort) {
    try {
      await staticReady; // vänta in sl.zip
      currentLine = lineShort;

      setStatus(`Hämtar positioner för linje ${lineShort}…`);

      // Hämta båda feeds parallellt (TripUpdates först för mappning)
      const [_, vehRes] = await Promise.all([
        loadTripUpdates(),               // fyller VEHICLE_TO_ROUTE
        fetch(VEH_URL)                   // VehiclePositions
      ]);
      if (!vehRes.ok) {
        setStatus(`VehiclePositions misslyckades: ${vehRes.status}`);
        return;
      }

      const bytes = new Uint8Array(await vehRes.arrayBuffer());
      const feed = FeedMessage.decode(bytes);
      const entities = feed.entity || [];

      // Bygg live-översikt av linjer i feeden
      const shortsNow = new Map();
      const vehicles = [];

      for (const ent of entities) {
        const v = ent.vehicle;
        if (!v || !v.position) continue;

        // 1) Försök direkt från VehiclePositions.trip
        let s = shortFromTrip(v.trip);

        // 2) Fallback via TripUpdates (vehicle.id -> routeId -> short)
        if (!s && v.vehicle?.id) {
          const rid2 = VEHICLE_TO_ROUTE.get((v.vehicle.id||"").trim());
          if (rid2) s = SHORT_BY_ROUTE.get(rid2) || guessShortFromRouteId(rid2) || null;
        }

        if (s) shortsNow.set(s, (shortsNow.get(s) || 0) + 1);
        if (s === lineShort) vehicles.push(v);
      }

      console.log("Aktiva linjer just nu (short -> count):", Object.fromEntries(shortsNow));

      // Rensa & rita
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      if (vehicles.length === 0) {
        setStatus(`Inga aktiva fordon hittades just nu för linje ${lineShort}. (Aktiva linjer nu: ${[...shortsNow.keys()].slice(0,15).join(", ") || "okänt"})`);
        return;
      }

      const group = [];
      for (const v of vehicles) {
        const { latitude:lat, longitude:lon, bearing } = v.position;
        const label = (v.vehicle && (v.vehicle.label || v.vehicle.id)) || "okänt fordon";
        const m = L.marker([lat, lon]).addTo(map)
          .bindPopup(`<b>Linje ${lineShort}</b><br>Fordon: ${label}<br>Riktning: ${bearing ?? "–"}°`);
        markers.push(m);
        group.push([lat, lon]);
      }
      if (group.length) {
        const bounds = L.latLngBounds(group);
        map.fitBounds(bounds.pad(0.2));
      }
      setStatus(`Visar ${vehicles.length} fordon för linje ${lineShort}.`);
      $meta.textContent = `linje ${lineShort}`;
    } catch (err) {
      console.error(err);
      setStatus("Kunde inte hämta/avkoda realtid. Se konsolen.");
    }
  }

  // =============== UI ===============
  document.getElementById("line-form").addEventListener("submit", async (e) => {
    e.preventDefault();
    const line = $line.value.trim();
    if (!line) return;
    await fetchPositions(line);

    if ($auto.checked) {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = setInterval(() => fetchPositions(line), 10000);
    } else if (autoTimer) {
      clearInterval(autoTimer);
      autoTimer = null;
    }
  });

  // =============== Init ===============
  (async () => {
    await loadStatic();
    setStatus("Skriv ett linjenummer (t.ex. 4) och tryck Enter.");
  })();
  </script>
</body>
</html>
