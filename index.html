<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SL-bussar i realtid</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <style>
    :root { --bg:#0b0c10; --panel:#151824; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4f46e5; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    header{padding:10px 14px;background:var(--panel);display:flex;flex-wrap:wrap;gap:10px;align-items:center;position:sticky;top:0;z-index:2}
    label{opacity:.9}
    input,button{border:1px solid #23273a;background:#0f1320;color:var(--text);padding:9px 12px;border-radius:10px}
    input{min-width:90px}
    button{cursor:pointer}
    .row{display:flex;gap:10px;align-items:center}
    #status{padding:8px 14px;color:var(--muted)}
    #map{height:calc(100vh - 108px)}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:2px 8px;border:1px solid #2a2f43;border-radius:999px;margin-left:6px;color:#cbd5e1}
  </style>
</head>
<body>
  <header>
    <form id="line-form" class="row">
      <label for="line">Linje</label>
      <input id="line" placeholder="t.ex. 4" required inputmode="numeric" />
      <button id="go" type="submit" title="Visa bussar">Visa</button>
    </form>
    <div class="row">
      <label for="auto">Auto-uppdatera</label>
      <input id="auto" type="checkbox" />
      <span class="pill" id="meta">laddar‚Ä¶</span>
    </div>
  </header>

  <div id="status">Laddar statiska filer f√∂rsta g√•ngen‚Ä¶</div>
  <div id="map"></div>

  <!-- Libs -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js"></script>

  <script>
  // ================== KONFIG ==================
  // Din Cloudflare-proxy (m√•ste st√∂dja bin√§r pass-through + CORS: "*")
  const API_PROXY = "https://buss-proxy.nyhet24-tokamak.workers.dev";

  // üîë Trafiklab-nycklar (om du inte g√∂mmer dem i Workern)
  const TL_RT_KEY     = "ac506a874e764f75a02d214788ec2124";     // Realtime: VehiclePositions
  const TL_STATIC_KEY = "b2f9006366ce457dab592e5e3ca60410"; // Static: sl.zip

  // Upstream-URL:er (anv√§nds via proxyn)
  const VEH_URL_UPSTREAM = `https://opendata.samtrafiken.se/gtfs-rt/sl/VehiclePositions.pb?key=${TL_RT_KEY}`;
  const SL_ZIP_UPSTREAM  = `https://opendata.samtrafiken.se/gtfs/sl/sl.zip?key=${TL_STATIC_KEY}`;

  // Slutliga URL:er (proxade)
  const VEH_URL = `${API_PROXY}/?url=${encodeURIComponent(VEH_URL_UPSTREAM)}`;
  const SL_ZIP  = `${API_PROXY}/?url=${encodeURIComponent(SL_ZIP_UPSTREAM)}`;

  // =============== GTFS-Realtime .proto (utdrag som r√§cker f√∂r VehiclePositions) ===============
  const GTFS_PROTO = `
  syntax = "proto2";
  package transit_realtime;
  message FeedMessage { required FeedHeader header = 1; repeated FeedEntity entity = 2; }
  message FeedHeader { required string gtfs_realtime_version = 1; optional uint64 timestamp = 3; }
  message FeedEntity { required string id = 1; optional VehiclePosition vehicle = 3; }
  message TripDescriptor { optional string trip_id = 1; optional string route_id = 5; }
  message VehicleDescriptor { optional string id = 1; optional string label = 2; }
  message Position { optional float latitude = 1; optional float longitude = 2; optional float bearing = 3; }
  message VehiclePosition {
    optional TripDescriptor trip = 1;
    optional Position position = 2;
    optional int32 current_stop_sequence = 3;
    optional uint64 timestamp = 5;
    optional VehicleDescriptor vehicle = 8;
  }`;
  const root = protobuf.parse(GTFS_PROTO).root;
  const FeedMessage = root.lookupType("transit_realtime.FeedMessage");

  // =============== KARTA ===============
  const map = L.map("map").setView([59.3328, 18.0649], 12);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution:"¬© OpenStreetMap" }).addTo(map);

  let markers = [];
  let ROUTES_BY_SHORT = new Map(); // '4' -> Set(route_id, ...)
  let ROUTE_BY_TRIP   = new Map(); // trip_id -> route_id
  let currentLine = null;
  let autoTimer = null;

  const $status = document.getElementById("status");
  const $meta   = document.getElementById("meta");
  const $auto   = document.getElementById("auto");
  const $line   = document.getElementById("line");
  const $go     = document.getElementById("go");

  const setStatus = (t) => { $status.textContent = t; console.log(t); };

  // ‚Äî Gatea UI tills statiken √§r klar ‚Äî
  let staticReadyResolve;
  const staticReady = new Promise(res => (staticReadyResolve = res));
  $line.disabled = true; $go.disabled = true;

  // =============== Ladda statisk GTFS (routes & trips) fr√•n sl.zip ===============
  async function loadStatic() {
    try {
      setStatus("H√§mtar sl.zip‚Ä¶");
      const res = await fetch(SL_ZIP);
      if (!res.ok) throw new Error(`sl.zip misslyckades: ${res.status}`);
      const buf = await res.arrayBuffer();
      const zip = await JSZip.loadAsync(buf);

      // routes.txt
      const routesTxt = await zip.file("routes.txt").async("string");
      const routes = Papa.parse(routesTxt, { header:true, skipEmptyLines:true }).data;
      ROUTES_BY_SHORT = new Map();
      for (const r of routes) {
        const rid = (r.route_id||"").trim();
        const short = (r.route_short_name||"").trim();
        if (!rid || !short) continue;
        if (!ROUTES_BY_SHORT.has(short)) ROUTES_BY_SHORT.set(short, new Set());
        ROUTES_BY_SHORT.get(short).add(rid);
      }

      // trips.txt (trip_id -> route_id f√∂r fallback)
      const tripsTxt = await zip.file("trips.txt").async("string");
      const trips = Papa.parse(tripsTxt, { header:true, skipEmptyLines:true }).data;
      ROUTE_BY_TRIP = new Map();
      for (const t of trips) {
        const tripId = (t.trip_id||"").trim();
        const routeId = (t.route_id||"").trim();
        if (tripId && routeId) ROUTE_BY_TRIP.set(tripId, routeId);
      }

      setStatus(`Statiska filer klara: ${ROUTES_BY_SHORT.size} linjer, ${ROUTE_BY_TRIP.size} trips mappade.`);
      $meta.textContent = "redo";
      $line.disabled = false; $go.disabled = false;
      staticReadyResolve();
    } catch (err) {
      console.error(err);
      setStatus("Kunde inte ladda statisk data (sl.zip). Har din nyckel √•tkomst? Annars anv√§nd Sweden-zip som fallback.");
      $meta.textContent = "fel statiskt";
    }
  }

  // =============== H√§mta realtidspositioner och filtrera p√• linje ===============
  async function fetchPositions(lineShort) {
    try {
      currentLine = lineShort;
      const routeIds = ROUTES_BY_SHORT.get(lineShort);
      if (!routeIds) {
        setStatus(`Hittar ingen linje ‚Äú${lineShort}‚Äù i routes.txt (anv√§nd kortnamn, t.ex. 4).`);
        return;
      }

      setStatus(`H√§mtar positioner f√∂r linje ${lineShort}‚Ä¶`);
      const res = await fetch(VEH_URL);
      if (!res.ok) {
        setStatus(`H√§mtning av VehiclePositions misslyckades: ${res.status}`);
        return;
      }

      const buf = await res.arrayBuffer();
      const bytes = new Uint8Array(buf);
      const feed = FeedMessage.decode(bytes);

      const want = new Set(routeIds);
      const vehicles = [];

      for (const ent of (feed.entity || [])) {
        const v = ent.vehicle;
        if (!v || !v.position) continue;
        const t = v.trip || {};

        // OBS: protobuf.js g√∂r f√§lten camelCase ‚Üí routeId / tripId
        const byRouteId = t.routeId && want.has((t.routeId||"").trim());
        let byTrip = false;
        if (!byRouteId && t.tripId) {
          const mapped = ROUTE_BY_TRIP.get((t.tripId||"").trim());
          if (mapped && want.has(mapped)) byTrip = true;
        }
        if (byRouteId || byTrip) vehicles.push(v);
      }

      // Rensa och rita
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      if (vehicles.length === 0) {
        setStatus(`Inga aktiva fordon hittades just nu f√∂r linje ${lineShort}. Prova igen strax eller testa en annan linje.`);
        return;
      }

      const group = [];
      for (const v of vehicles) {
        const { latitude:lat, longitude:lon, bearing } = v.position;
        const label = (v.vehicle && (v.vehicle.label || v.vehicle.id)) || "ok√§nt fordon";
        const m = L.marker([lat, lon]).addTo(map)
          .bindPopup(`<b>Linje ${lineShort}</b><br>Fordon: ${label}<br>Riktning: ${bearing ?? "‚Äì"}¬∞`);
        markers.push(m);
        group.push([lat, lon]);
      }
      if (group.length) {
        const bounds = L.latLngBounds(group);
        map.fitBounds(bounds.pad(0.2));
      }
      setStatus(`Visar ${vehicles.length} fordon f√∂r linje ${lineShort}.`);
      $meta.textContent = `linje ${lineShort}`;
    } catch (err) {
      console.error(err);
      setStatus("Kunde inte h√§mta/avkoda realtid. Se konsolen.");
    }
  }

  // =============== UI-h√§ndelser ===============
  document.getElementById("line-form").addEventListener("submit", async (e) => {
    e.preventDefault();
    const line = $line.value.trim();
    if (!line) return;
    // V√§nta alltid in statisk inl√§sning (fixar race condition)
    await staticReady;
    fetchPositions(line);

    if ($auto.checked) {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = setInterval(() => fetchPositions(line), 10000);
    } else if (autoTimer) {
      clearInterval(autoTimer);
      autoTimer = null;
    }
  });

  // =============== Init ===============
  (async () => {
    await loadStatic();
    setStatus("Skriv ett linjenummer (t.ex. 4) och tryck Enter.");
  })();
  </script>
</body>
</html>
